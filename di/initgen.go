package di

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"reflect"
	"strings"
	"unicode"

	"github.com/moznion/gowrtr/generator"
	"golang.org/x/tools/go/ast/astutil"
)

// getCurrentPkg returns the go pkg in the working dir.
func getCurrentPkg() string {
	pkgImport, err := exec.Command("go", "list", "-f", "{{.ImportPath}}", ".").Output()
	check(err)

	return string(bytes.TrimSpace(pkgImport))
}

func check(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func trimPkgPrefix(s string, pkg string) string {
	isPointer := false
	if tmp := strings.TrimPrefix(s, "*"); tmp != s {
		s = tmp
		isPointer = true
	}
	s = strings.TrimPrefix(s, pkg+".")
	if isPointer {
		s = "*" + s
	}
	return s
}

func trimAnyPkgPrefix(s string) string {
	safeName := strings.Split(s, ".")
	name := safeName[len(safeName)-1]
	return name
}

type initter struct {
	typ        reflect.Type
	deps       []initter
	returnsErr bool
	isExported bool
}

func newInitter(provider reflect.Type, depProviders []reflect.Type) initter {
	depInits := make([]initter, len(depProviders))
	for i, dep := range depProviders {
		depInits[i] = newInitter(dep, nil)
	}

	f := initter{
		typ:        provider.Out(0),
		deps:       depInits,
		returnsErr: provider.NumOut() == 2,
	}

	if unicode.IsUpper([]rune(trimAnyPkgPrefix(f.typ.String()))[0]) {
		f.isExported = true
	}

	return f
}

// typeName in the pkg context.
func (f initter) typeName(pkg string) string {
	return trimPkgPrefix(f.typ.String(), pkg)
}

// varname referring to this initFunc.
func (f initter) varName() string {
	// TODO string case
	return trimAnyPkgPrefix(f.typ.String())
}

func (f initter) callName() string {
	prefix := "init"
	if f.isExported {
		prefix = "Init"
	}
	return prefix + f.varName()
}

func (f initter) zero() string {
	switch f.typ.Kind() {
	case reflect.Chan,
		reflect.Func,
		reflect.Interface,
		reflect.Map,
		reflect.Ptr,
		reflect.Slice:
		return "nil"
	default:
		return fmt.Sprintf("%#v", reflect.Zero(f.typ).Interface())
	}
}

func createInits(c *Container) []initter {
	var inits []initter

	c.Range(func(item *Item) bool {
		deps := make([]reflect.Type, len(item.node.Edges))
		for i, edge := range item.node.Edges {
			deps[i] = edge.Value.(*Item).provider.Type()
		}
		inits = append(inits, newInitter(item.provider.Type(), deps))
		return true
	})

	return inits
}

func createStatements(f initter, provider, args string) []generator.Statement {
	if f.returnsErr {
		return []generator.Statement{
			generator.NewRawStatement(
				fmt.Sprintf("%s, err := %s(%s)", f.varName(), provider, args),
			),

			generator.NewRawStatement(
				fmt.Sprintf("if err != nil { return %s, err }", f.zero()),
			),
		}
	}

	return []generator.Statement{
		generator.NewRawStatement(
			fmt.Sprintf("%s := %s(%s)", f.varName(), provider, args),
		),
	}
}

// Generate code for type initializers in the context of the resolved container.
func Generate(register func(*Container)) {
	c := NewContainer()
	register(c)
	check(c.Resolve())

	inits := createInits(c)

	cwd, err := os.Getwd()
	check(err)

	source := filepath.Join(cwd, "initgen.go")
	fset, node := parseFile(source)
	imports := parseImports(fset, node)
	providers := parseProviders(node)

	curPkg := path.Base(getCurrentPkg())
	g := generator.NewRoot(
		generator.NewComment(" DO NOT EDIT. This code is generated by initgen."),
		generator.NewPackage(curPkg),
		generator.NewNewline(),
		generator.NewImport(imports...),
		generator.NewNewline(),
	)

	for _, f := range inits {
		sig := generator.NewFuncSignature(f.callName())
		sig = sig.AddReturnTypes(f.typeName(curPkg))
		if f.returnsErr {
			sig = sig.AddReturnTypes("error")
		}

		initFunc := generator.NewFunc(nil, sig)

		// Collect arguments for type provider function.
		var providerArgs []string
		for _, dep := range f.deps {
			depName := dep.varName()
			providerArgs = append(providerArgs, depName)
			initFunc = initFunc.AddStatements(createStatements(dep, dep.callName(), "")...)
		}

		// check the ordering of Register calls.
		var index uint64
		typ := f.typ
		c.Range(func(item *Item) bool {
			if typ == item.provider.Type().Out(0) {
				index = item.index
				return false
			}
			return true
		})

		// get call ident by item index
		provider := providers[index]
		args := strings.Join(providerArgs, ", ")

		initFunc = initFunc.AddStatements(createStatements(f, provider, args)...)

		var ret generator.Statement
		if f.returnsErr {
			ret = generator.NewRawStatement(fmt.Sprintf("return %s, nil", f.varName()))
		} else {
			ret = generator.NewRawStatement("return " + f.varName())
		}

		initFunc = initFunc.AddStatements(ret)

		g = g.AddStatements(initFunc, generator.NewNewline())
	}

	generated, err := g.Generate(0)
	if err != nil {
		panic(err)
	}

	generated = strings.TrimSuffix(generated, "\n")

	check(ioutil.WriteFile(filepath.Join(cwd, "init.go"), []byte(generated), 0o644))
}

func parseImports(fset *token.FileSet, f *ast.File) []string {
	var imports []string

	importSpecs := astutil.Imports(fset, f)
	for _, specs := range importSpecs {
		for _, spec := range specs {
			astutil.Apply(spec, func(c *astutil.Cursor) bool {
				switch t := c.Node().(type) {
				case *ast.BasicLit:
					imp := strings.Trim(t.Value, `"`)
					if imp != "github.com/mgnsk/di-container/di" {
						imports = append(imports, imp)
						return false
					}
				}
				return true
			}, nil)
		}
	}

	return imports
}

func parseProviders(node ast.Node) []string {
	containers := parsecontainers(node)
	if len(containers) != 1 {
		panic("container missing or invalid number of")
	}

	providers := parseRegister(containers[0])
	funcs := make([]string, len(providers))

	for i, r := range providers {
		switch t := r.f.Args[0].(type) {
		case *ast.FuncLit:
			panic("initgen: Register functions must not be literal")

		case *ast.Ident:
			funcs[i] = getNonNilIdent(t)

		case *ast.SelectorExpr:
			funcs[i] = getNonNilIdent(t)

		default:
			panic(fmt.Errorf("initgen: invalid Register argument type: '%T'", t))
		}
	}

	return funcs
}

type container struct {
	f *ast.CallExpr
}

func isFunction(t *ast.CallExpr, pkg, fn string) bool {
	if fun, ok := t.Fun.(*ast.SelectorExpr); ok {
		if x, ok := fun.X.(*ast.Ident); ok &&
			x.Name == pkg &&
			fun.Sel.Name == fn {
			return true
		}
	}
	return false
}

func parsecontainers(node ast.Node) []container {
	var containers []container
	astutil.Apply(node, func(c *astutil.Cursor) bool {
		switch t := c.Node().(type) {
		case *ast.CallExpr:
			if isFunction(t, "di", "Generate") {
				containers = append(containers, container{
					f: t,
				})
				return false
			}
		}
		return true
	}, nil)
	return containers
}

type registerCall struct {
	f *ast.CallExpr
}

func parseRegister(container container) []registerCall {
	var calls []registerCall
	astutil.Apply(container.f, func(c *astutil.Cursor) bool {
		switch t := c.Node().(type) {
		case *ast.CallExpr:
			if isFunction(t, "c", "Register") {
				calls = append(calls, registerCall{
					f: t,
				})
				return false
			}
		}
		return true
	}, nil)
	return calls
}

func parseFile(filename string) (*token.FileSet, *ast.File) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	check(err)

	return fset, node
}

func getNonNilIdent(node ast.Node) string {
	var ident string
	astutil.Apply(node, func(c *astutil.Cursor) bool {
		switch t := c.Node().(type) {
		case *ast.Ident:
			if t.Name == "nil" {
				return false
			}
			ident = t.Name
			if se, ok := c.Parent().(*ast.SelectorExpr); ok {
				if x, ok := se.X.(*ast.Ident); ok {
					ident = x.Name + "." + t.Name
				}
			}
		}
		return true
	}, nil)
	return ident
}
