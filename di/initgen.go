package di

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"reflect"
	"strings"
	"unicode"

	"github.com/moznion/gowrtr/generator"
	"golang.org/x/tools/go/ast/astutil"
)

// GetCurrentPkg returns the go pkg in the working dir.
func GetCurrentPkg() string {
	pkgImport, err := exec.Command("go", "list", "-f", "{{.ImportPath}}", ".").Output()
	check(err)

	return string(bytes.TrimSpace(pkgImport))
}

func check(err error) {
	if err != nil {
		panic(err)
	}
}

func trimPkgPrefix(s string, pkg string) string {
	isPointer := false
	if tmp := strings.TrimPrefix(s, "*"); tmp != s {
		s = tmp
		isPointer = true
	}
	s = strings.TrimPrefix(s, pkg+".")
	if isPointer {
		s = "*" + s
	}
	return s
}

func trimAnyPkgPrefix(s string) string {
	safeName := strings.Split(s, ".")
	name := safeName[len(safeName)-1]
	return name
}

type initter struct {
	typ          reflect.Type
	deps         []initter
	handlesError bool
	isExported   bool
}

func newInitFunc(provider reflect.Type, depProviders []reflect.Type) initter {
	depInits := make([]initter, len(depProviders))
	for i, dep := range depProviders {
		depInits[i] = newInitFunc(dep, nil)
	}

	f := initter{
		typ:          provider.Out(0),
		deps:         depInits,
		handlesError: provider.NumOut() == 2,
	}

	if unicode.IsUpper([]rune(trimAnyPkgPrefix(f.typ.String()))[0]) {
		f.isExported = true
	}

	return f
}

// typeName in the pkg context.
func (t *initter) typeName(pkg string) string {
	return trimPkgPrefix(t.typ.String(), pkg)
}

// varname referring to this initFunc.
func (t *initter) varName() string {
	// TODO string case
	return trimAnyPkgPrefix(t.typ.String())
}

func (t *initter) callName() string {
	prefix := "init"
	if t.isExported {
		prefix = "Init"
	}
	return prefix + t.varName()
}

func createInits(c *Container) []initter {
	var inits []initter

	c.Range(func(item *Item) bool {
		deps := make([]reflect.Type, len(item.node.Edges))
		for i, edge := range item.node.Edges {
			deps[i] = edge.Value.(*Item).provider.Type()
		}
		inits = append(inits, newInitFunc(item.provider.Type(), deps))
		return true
	})

	return inits
}

// Generate code for type initializers in the context of the resolved container.
func Generate(register func(*Container)) {
	c := NewContainer()
	register(c)
	check(c.Resolve())

	inits := createInits(c)

	// Parse source file.
	filename, err := filepath.Abs(filepath.Join(".", "initgen.go"))
	check(err)

	fset, node := parseFile(filename)
	imports := parseImports(fset, node)
	funcs := parseDefaultNewFuncs(node)

	curPkg := path.Base(GetCurrentPkg())

	g := generator.NewRoot(
		generator.NewComment(" DO NOT EDIT. This code is generated by initgen."),
		generator.NewPackage(curPkg),
		generator.NewImport(imports...),
		generator.NewNewline(),
	)

	for _, f := range inits {
		sig := generator.NewFuncSignature(f.callName())
		sig = sig.AddReturnTypes(f.typeName(curPkg))
		initFunc := generator.NewFunc(nil, sig)

		// Collect arguments for type provider function.
		var providerArgs []string
		for _, dep := range f.deps {
			varName := dep.varName()
			providerArgs = append(providerArgs, varName)
			initFunc = initFunc.AddStatements(
				generator.NewRawStatement(fmt.Sprintf(
					"%s := %s()",
					varName,
					dep.callName(),
				)),
			)
		}

		// check the ordering of Register calls.
		var index uint64
		typ := f.typ
		c.Range(func(item *Item) bool {
			if typ == item.provider.Type().Out(0) {
				index = item.index
				return false
			}
			return true
		})

		varName := f.varName()
		// get call ident by item index
		newIdent := funcs[index]
		argString := strings.Join(providerArgs, ", ")

		if f.handlesError {
			line := fmt.Sprintf(
				"%s, err := %s(%s)",
				varName,
				newIdent,
				argString,
			)

			// Returns a value + error.
			initFunc = initFunc.AddStatements(
				generator.NewRawStatement(line),
				generator.NewRawStatement(`if err != nil { panic(err) }`),
			)
		} else {
			line := fmt.Sprintf(
				"%s := %s(%s)",
				varName,
				newIdent,
				argString,
			)

			// Returns only value.
			initFunc = initFunc.AddStatements(
				generator.NewRawStatement(line),
			)
		}

		initFunc = initFunc.AddStatements(
			generator.NewRawStatement("return " + varName),
		)

		g = g.AddStatements(initFunc, generator.NewNewline())
	}

	g = g.Gofmt("-s").
		Goimports().
		EnableSyntaxChecking()

	generated, err := g.Generate(0)
	if err != nil {
		panic(err)
	}

	check(ioutil.WriteFile(filepath.Join(".", "init.go"), []byte(generated), os.ModePerm))

	// Run goimports again, apparently sometimes it doesn't remove all unused imports and thus needs 2 passes.
	_, err = exec.Command("goimports", "-w", "init.go").Output()
	check(err)
}

func parseImports(fset *token.FileSet, f *ast.File) []string {
	var imports []string

	importSpecs := astutil.Imports(fset, f)
	for _, specs := range importSpecs {
		for _, spec := range specs {
			astutil.Apply(spec, func(c *astutil.Cursor) bool {
				switch t := c.Node().(type) {
				case *ast.BasicLit:
					imp := strings.Trim(t.Value, `"`)
					if imp != "github.com/mgnsk/di-container/di" {
						imports = append(imports, imp)
						return false
					}
				}
				return true
			}, nil)
		}
	}

	return imports
}

func parseDefaultNewFuncs(node ast.Node) []string {
	containers := parsecontainers(node)
	if len(containers) != 1 {
		panic("container missing or invalid number of")
	}

	registers := parseRegister(containers[0])

	return parseNewFuncs(registers)
}

type container struct {
	f *ast.CallExpr
}

func isFunction(t *ast.CallExpr, pkg, fn string) bool {
	if fun, ok := t.Fun.(*ast.SelectorExpr); ok {
		if x, ok := fun.X.(*ast.Ident); ok &&
			x.Name == pkg &&
			fun.Sel.Name == fn {
			return true
		}
	}
	return false
}

func parsecontainers(node ast.Node) []container {
	var containers []container
	astutil.Apply(node, func(c *astutil.Cursor) bool {
		switch t := c.Node().(type) {
		case *ast.CallExpr:
			if isFunction(t, "di", "Generate") {
				containers = append(containers, container{
					f: t,
				})
				return false
			}
		}
		return true
	}, nil)
	return containers
}

type registerCall struct {
	f *ast.CallExpr
}

func parseRegister(container container) []registerCall {
	var calls []registerCall
	astutil.Apply(container.f, func(c *astutil.Cursor) bool {
		switch t := c.Node().(type) {
		case *ast.CallExpr:
			if isFunction(t, "c", "Register") {
				calls = append(calls, registerCall{
					f: t,
				})
				return false
			}
		}
		return true
	}, nil)
	return calls
}

func parseNewFuncs(registers []registerCall) []string {
	funcs := make([]string, len(registers))

	for i, r := range registers {
		switch t := r.f.Args[0].(type) {
		case *ast.FuncLit:
			panic("initgen: Register functions must not be literal")

		case *ast.Ident:
			funcs[i] = getNonNilIdent(t)

		case *ast.SelectorExpr:
			funcs[i] = getNonNilIdent(t)

		default:
			panic(fmt.Errorf("initgen: invalid Register argument type: '%T'", t))
		}
	}

	return funcs
}

func parseFile(filename string) (*token.FileSet, *ast.File) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	check(err)

	return fset, node
}

func getNonNilIdent(node ast.Node) string {
	var ident string
	astutil.Apply(node, func(c *astutil.Cursor) bool {
		switch t := c.Node().(type) {
		case *ast.Ident:
			if t.Name == "nil" {
				return false
			}
			ident = t.Name
			if se, ok := c.Parent().(*ast.SelectorExpr); ok {
				if x, ok := se.X.(*ast.Ident); ok {
					ident = x.Name + "." + t.Name
				}
			}
		}
		return true
	}, nil)
	return ident
}
