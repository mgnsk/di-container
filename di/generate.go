package di

import (
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/mgnsk/di-container/initgen"
	"github.com/moznion/gowrtr/generator"
)

// Generate code for type initializers in the context of the resolved container.
func Generate(register func(*Container)) (dummy struct{}) {
	c := NewContainer()
	register(c)
	if err := c.Resolve(); err != nil {
		panic(err)
	}

	curPkg := path.Base(initgen.GetCurrentPackage())
	trim := func(s string) string {
		s = strings.TrimPrefix(s, "*")
		s = strings.TrimPrefix(s, curPkg+".")
		return s
	}

	type dep struct {
		name            string
		isPointer       bool
		deps            []string
		providerReturns int
		newFunc         string
	}

	// Collect type dependencies.
	deps := make(map[string]*dep)
	var order []*dep

	c.Range(func(item *Item) {
		d := &dep{
			name:            trim(item.typ.String()),
			isPointer:       item.isPointer,
			deps:            make([]string, len(item.n.Edges)),
			providerReturns: item.provider.Type().NumOut(),
		}
		for i, n := range item.n.Edges {
			depItem := n.Value.(*Item)
			d.deps[i] = trim(depItem.typ.String())
		}
		order = append(order, d)
		deps[d.name] = d
	})

	safename := func(s string) string {
		safeName := strings.Split(s, ".")
		name := safeName[len(safeName)-1]
		return name
	}

	// Parse functions from source code.
	// The names don't contain package prefixers. (TODO clean up logic)
	newFuncs := parseNewFuncs()
	for typeName, fName := range newFuncs {
		for _, d := range deps {
			if safename(d.name) == typeName {
				d.newFunc = fName
			}
		}
	}

	// Package which is being generated.
	pkg := initgen.GetCurrentPackage()

	g := generator.NewRoot(
		generator.NewComment(" DO NOT EDIT. This code is generated by initgen."),
		generator.NewPackage(path.Base(pkg)),
		//	generator.NewImport(pkg),
		// TODO it seems the auto imports work.
		generator.NewNewline(),
	)

	for _, d := range order {
		name := safename(d.name)

		sig := generator.NewFuncSignature("init" + name)

		var returnType string
		if d.isPointer {
			returnType = "*" + d.name
		} else {
			returnType = d.name
		}

		sig = sig.AddReturnTypes(returnType)
		initFunc := generator.NewFunc(nil, sig)

		// Collect arguments for type provider function.
		var providerArgs []string
		for _, depName := range deps[d.name].deps {
			varName := strings.ToLower(safename(depName))
			providerArgs = append(providerArgs, varName)

			initFunc = initFunc.AddStatements(
				generator.NewRawStatement(fmt.Sprintf(
					"%s := init%s()",
					varName,
					safename(depName),
				)),
			)
		}

		varName := strings.ToLower(name)

		argString := strings.Join(providerArgs, ", ")

		if d.providerReturns == 2 {
			// Returns a value + error.
			initFunc = initFunc.AddStatements(
				generator.NewRawStatement(fmt.Sprintf(
					"%s, err := %s(%s)",
					varName,
					d.newFunc,
					argString,
				)),
				generator.NewRawStatement(`if err != nil { panic(err) }`),
			)
		} else {
			// Returns only value.
			initFunc = initFunc.AddStatements(
				generator.NewRawStatement(fmt.Sprintf(
					"%s := %s(%s)",
					varName,
					d.newFunc,
					argString,
				)),
			)
		}

		initFunc = initFunc.AddStatements(
			generator.NewRawStatement("return " + varName),
		)

		g = g.AddStatements(initFunc)
	}

	g = g.Gofmt("-s").Goimports()

	generated, err := g.Generate(0)
	if err != nil {
		panic(err)
	}

	if err := ioutil.WriteFile(filepath.Join(".", "init.go"), []byte(generated), os.ModePerm); err != nil {
		panic(err)
	}

	return
}

func parseNewFuncs() map[string]string {
	filename, err := filepath.Abs(filepath.Join(".", "initgen.go"))
	if err != nil {
		panic(err)
	}

	fset, node := initgen.ParseFile(filename)

	containers := initgen.ParseContainers(node)
	if len(containers) != 1 {
		panic("Container missing or invalid number of")
	}

	registers := initgen.ParseRegister(containers[0])
	_ = registers

	lmap := initgen.ParseNewFuncs(fset, registers)

	return lmap
}
